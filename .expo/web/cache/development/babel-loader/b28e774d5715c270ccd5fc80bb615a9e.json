{"ast":null,"code":"import processColor from 'react-native/Libraries/StyleSheet/processColor';\nimport Color from 'art/core/color';\nimport Transform from 'art/core/transform';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nexport function childrenAsString(children) {\n  if (!children) {\n    return '';\n  }\n\n  if (typeof children === 'string') {\n    return children;\n  }\n\n  if (children.length) {\n    return children.join('\\n');\n  }\n\n  return '';\n}\nexport function extractOpacity(_ref) {\n  var visible = _ref.visible,\n      opacity = _ref.opacity;\n\n  if (visible === false) {\n    return 0;\n  }\n\n  if (opacity == null) {\n    return 1;\n  }\n\n  return +opacity;\n}\nvar pooledTransform = new Transform();\nexport function extractTransform(props) {\n  var scaleX = props.scaleX != null ? props.scaleX : props.scale != null ? props.scale : 1;\n  var scaleY = props.scaleY != null ? props.scaleY : props.scale != null ? props.scale : 1;\n  pooledTransform.transformTo(1, 0, 0, 1, 0, 0).move(props.x || 0, props.y || 0).rotate(props.rotation || 0, props.originX, props.originY).scale(scaleX, scaleY);\n\n  if (props.transform != null) {\n    pooledTransform.transform(props.transform);\n  }\n\n  return [pooledTransform.xx, pooledTransform.yx, pooledTransform.xy, pooledTransform.yy, pooledTransform.x, pooledTransform.y];\n}\n\nfunction toHex(color) {\n  var intValues = [color.red, color.green, color.blue];\n\n  if (color.alpha < 1) {\n    var position = Platform.OS === 'android' ? 0 : 3;\n    intValues.splice(position, 0, Math.round(color.alpha * 255));\n  }\n\n  var hexValues = intValues.map(function (iv) {\n    var sv = iv.toString(16);\n    return sv.length === 1 ? '0' + sv : sv;\n  });\n  return '#' + hexValues.join('');\n}\n\nexport function extractShadow(props) {\n  var _props$shadowOffset, _props$shadowOffset2;\n\n  if (!props.shadowColor && !props.shadowOpacity && !props.shadowRadius && !props.shadowOffset) {\n    return;\n  }\n\n  var opacity = props.shadowOpacity;\n\n  if (opacity === null || opacity === undefined) {\n    opacity = 1;\n  }\n\n  return [processColor(props.shadowColor || 'black'), opacity, props.shadowRadius || 4, ((_props$shadowOffset = props.shadowOffset) == null ? void 0 : _props$shadowOffset.x) || 0, ((_props$shadowOffset2 = props.shadowOffset) == null ? void 0 : _props$shadowOffset2.y) || 0];\n}\nexport function extractColor(color) {\n  if (color == null) {\n    return null;\n  }\n\n  return toHex(new Color(color));\n}\nexport function extractStrokeJoin(strokeJoin) {\n  switch (strokeJoin) {\n    case 'miter':\n      return 0;\n\n    case 'bevel':\n      return 2;\n\n    default:\n      return 1;\n  }\n}\nexport function extractStrokeCap(strokeCap) {\n  switch (strokeCap) {\n    case 'butt':\n      return 0;\n\n    case 'square':\n      return 2;\n\n    default:\n      return 1;\n  }\n}\nvar SOLID_COLOR = 0;\nvar LINEAR_GRADIENT = 1;\nvar RADIAL_GRADIENT = 2;\nvar PATTERN = 3;\n\nfunction applyBoundingBoxToBrushData(brushData, props) {\n  var type = brushData[0];\n  var width = +props.width;\n  var height = +props.height;\n\n  if (type === LINEAR_GRADIENT) {\n    brushData[1] *= width;\n    brushData[2] *= height;\n    brushData[3] *= width;\n    brushData[4] *= height;\n  } else if (type === RADIAL_GRADIENT) {\n    brushData[1] *= width;\n    brushData[2] *= height;\n    brushData[3] *= width;\n    brushData[4] *= height;\n    brushData[5] *= width;\n    brushData[6] *= height;\n  } else if (type === PATTERN) {}\n}\n\nexport function extractBrush(colorOrBrush, props) {\n  if (colorOrBrush == null) {\n    return null;\n  }\n\n  if (colorOrBrush._brush) {\n    if (colorOrBrush._bb) {\n      applyBoundingBoxToBrushData(colorOrBrush._brush, props);\n      colorOrBrush._bb = false;\n    }\n\n    return colorOrBrush._brush;\n  }\n\n  var c = new Color(colorOrBrush);\n  return [SOLID_COLOR, c.red / 255, c.green / 255, c.blue / 255, c.alpha];\n}\nexport function extractAlignment(alignment) {\n  switch (alignment) {\n    case 'right':\n      return 1;\n\n    case 'center':\n      return 2;\n\n    default:\n      return 0;\n  }\n}\nvar cachedFontObjectsFromString = {};\nvar fontFamilyPrefix = /^[\\s\"']*/;\nvar fontFamilySuffix = /[\\s\"']*$/;\n\nfunction extractSingleFontFamily(fontFamilyString) {\n  return fontFamilyString.split(',')[0].replace(fontFamilyPrefix, '').replace(fontFamilySuffix, '');\n}\n\nfunction parseFontString(font) {\n  if (cachedFontObjectsFromString.hasOwnProperty(font)) {\n    return cachedFontObjectsFromString[font];\n  }\n\n  var regexp = /^\\s*((?:(?:normal|bold|italic)\\s+)*)(?:(\\d+(?:\\.\\d+)?)[ptexm\\%]*(?:\\s*\\/.*?)?\\s+)?\\s*\\\"?([^\\\"]*)/i;\n  var match = regexp.exec(font);\n\n  if (!match) {\n    return null;\n  }\n\n  var fontFamily = extractSingleFontFamily(match[3]);\n  var fontSize = +match[2] || 12;\n  var isBold = /bold/.exec(match[1]);\n  var isItalic = /italic/.exec(match[1]);\n  cachedFontObjectsFromString[font] = {\n    fontFamily: fontFamily,\n    fontSize: fontSize,\n    fontWeight: isBold ? 'bold' : 'normal',\n    fontStyle: isItalic ? 'italic' : 'normal'\n  };\n  return cachedFontObjectsFromString[font];\n}\n\nfunction extractFont(font) {\n  if (font == null) {\n    return null;\n  }\n\n  if (typeof font === 'string') {\n    return parseFontString(font);\n  }\n\n  var fontFamily = extractSingleFontFamily(font.fontFamily);\n  var fontSize = +font.fontSize || 12;\n  var fontWeight = font.fontWeight != null ? font.fontWeight.toString() : '400';\n  return {\n    fontFamily: fontFamily,\n    fontSize: fontSize,\n    fontWeight: fontWeight,\n    fontStyle: font.fontStyle\n  };\n}\n\nvar newLine = /\\n/g;\nexport function extractFontAndLines(font, text) {\n  return {\n    font: extractFont(font),\n    lines: text.split(newLine)\n  };\n}\n\nfunction insertColorIntoArray(color, targetArray, atIndex) {\n  var c = new Color(color);\n  targetArray[atIndex + 0] = c.red / 255;\n  targetArray[atIndex + 1] = c.green / 255;\n  targetArray[atIndex + 2] = c.blue / 255;\n  targetArray[atIndex + 3] = c.alpha;\n}\n\nfunction insertColorsIntoArray(stops, targetArray, atIndex) {\n  var i = 0;\n\n  if ('length' in stops) {\n    while (i < stops.length) {\n      insertColorIntoArray(stops[i], targetArray, atIndex + i * 4);\n      i++;\n    }\n  } else {\n    for (var offset in stops) {\n      insertColorIntoArray(stops[offset], targetArray, atIndex + i * 4);\n      i++;\n    }\n  }\n\n  return atIndex + i * 4;\n}\n\nfunction insertOffsetsIntoArray(stops, targetArray, atIndex, multi, reverse) {\n  var offsetNumber;\n  var i = 0;\n\n  if ('length' in stops) {\n    while (i < stops.length) {\n      offsetNumber = i / (stops.length - 1) * multi;\n      targetArray[atIndex + i] = reverse ? 1 - offsetNumber : offsetNumber;\n      i++;\n    }\n  } else {\n    for (var offsetString in stops) {\n      offsetNumber = +offsetString * multi;\n      targetArray[atIndex + i] = reverse ? 1 - offsetNumber : offsetNumber;\n      i++;\n    }\n  }\n\n  return atIndex + i;\n}\n\nexport function insertColorStopsIntoArray(stops, targetArray, atIndex) {\n  var lastIndex = insertColorsIntoArray(stops, targetArray, atIndex);\n  insertOffsetsIntoArray(stops, targetArray, lastIndex, 1, false);\n}\nexport function insertDoubleColorStopsIntoArray(stops, targetArray, atIndex) {\n  var lastIndex = insertColorsIntoArray(stops, targetArray, atIndex);\n  lastIndex = insertColorsIntoArray(stops, targetArray, lastIndex);\n  lastIndex = insertOffsetsIntoArray(stops, targetArray, lastIndex, 0.5, false);\n  insertOffsetsIntoArray(stops, targetArray, lastIndex, 0.5, true);\n}","map":{"version":3,"sources":["C:/Users/Matt/Documents/GitHub/pro-creature-habits/node_modules/@react-native-community/art/lib/helpers.js"],"names":["processColor","Color","Transform","childrenAsString","children","length","join","extractOpacity","visible","opacity","pooledTransform","extractTransform","props","scaleX","scale","scaleY","transformTo","move","x","y","rotate","rotation","originX","originY","transform","xx","yx","xy","yy","toHex","color","intValues","red","green","blue","alpha","position","Platform","OS","splice","Math","round","hexValues","map","iv","sv","toString","extractShadow","shadowColor","shadowOpacity","shadowRadius","shadowOffset","undefined","extractColor","extractStrokeJoin","strokeJoin","extractStrokeCap","strokeCap","SOLID_COLOR","LINEAR_GRADIENT","RADIAL_GRADIENT","PATTERN","applyBoundingBoxToBrushData","brushData","type","width","height","extractBrush","colorOrBrush","_brush","_bb","c","extractAlignment","alignment","cachedFontObjectsFromString","fontFamilyPrefix","fontFamilySuffix","extractSingleFontFamily","fontFamilyString","split","replace","parseFontString","font","hasOwnProperty","regexp","match","exec","fontFamily","fontSize","isBold","isItalic","fontWeight","fontStyle","extractFont","newLine","extractFontAndLines","text","lines","insertColorIntoArray","targetArray","atIndex","insertColorsIntoArray","stops","i","offset","insertOffsetsIntoArray","multi","reverse","offsetNumber","offsetString","insertColorStopsIntoArray","lastIndex","insertDoubleColorStopsIntoArray"],"mappings":"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","sourcesContent":["/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\n\r\nimport processColor from 'react-native/Libraries/StyleSheet/processColor';\r\nimport Color from 'art/core/color';\r\nimport Transform from 'art/core/transform';\r\nimport {Platform} from 'react-native';\r\nimport type {\r\n  Alignment,\r\n  Brush,\r\n  ColorType,\r\n  Font,\r\n  GradientStops,\r\n  OpacityProps,\r\n  StrokeCap,\r\n  StrokeJoin,\r\n  TransformProps,\r\n  ShadowProps,\r\n} from './types';\r\n\r\nexport function childrenAsString(children?: string | Array<string>) {\r\n  if (!children) {\r\n    return '';\r\n  }\r\n  if (typeof children === 'string') {\r\n    return children;\r\n  }\r\n  if (children.length) {\r\n    return children.join('\\n');\r\n  }\r\n  return '';\r\n}\r\n\r\nexport function extractOpacity({visible, opacity}: OpacityProps) {\r\n  // TODO: visible === false should also have no hit detection\r\n  if (visible === false) {\r\n    return 0;\r\n  }\r\n  if (opacity == null) {\r\n    return 1;\r\n  }\r\n  return +opacity;\r\n}\r\n\r\nconst pooledTransform = new Transform();\r\n\r\nexport function extractTransform(props: TransformProps): Array<number> {\r\n  const scaleX =\r\n    props.scaleX != null ? props.scaleX : props.scale != null ? props.scale : 1;\r\n  const scaleY =\r\n    props.scaleY != null ? props.scaleY : props.scale != null ? props.scale : 1;\r\n\r\n  pooledTransform\r\n    .transformTo(1, 0, 0, 1, 0, 0)\r\n    .move(props.x || 0, props.y || 0)\r\n    .rotate(props.rotation || 0, props.originX, props.originY)\r\n    .scale(scaleX, scaleY);\r\n\r\n  if (props.transform != null) {\r\n    pooledTransform.transform(props.transform);\r\n  }\r\n\r\n  return [\r\n    pooledTransform.xx,\r\n    pooledTransform.yx,\r\n    pooledTransform.xy,\r\n    pooledTransform.yy,\r\n    pooledTransform.x,\r\n    pooledTransform.y,\r\n  ];\r\n}\r\n\r\nfunction toHex(color: Color) {\r\n  const intValues = [color.red, color.green, color.blue];\r\n  if (color.alpha < 1) {\r\n    // Android uses AARRGGBB ; iOS uses RRGGBBAA\r\n    // https://developer.android.com/reference/android/graphics/Color.html#parseColor(java.lang.String)\r\n    const position = Platform.OS === 'android' ? 0 : 3;\r\n    intValues.splice(position, 0, Math.round(color.alpha * 255));\r\n  }\r\n  const hexValues = intValues.map(iv => {\r\n    const sv = iv.toString(16);\r\n    return sv.length === 1 ? '0' + sv : sv;\r\n  });\r\n  return '#' + hexValues.join('');\r\n}\r\n\r\nexport function extractShadow(\r\n  props: ShadowProps,\r\n): Array<number | null | void> | void {\r\n  if (\r\n    !props.shadowColor &&\r\n    !props.shadowOpacity &&\r\n    !props.shadowRadius &&\r\n    !props.shadowOffset\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  let opacity = props.shadowOpacity;\r\n\r\n  if (opacity === null || opacity === undefined) {\r\n    opacity = 1;\r\n  }\r\n\r\n  return [\r\n    processColor(props.shadowColor || 'black'),\r\n    opacity,\r\n    props.shadowRadius || 4,\r\n    props.shadowOffset?.x || 0,\r\n    props.shadowOffset?.y || 0,\r\n  ];\r\n}\r\n\r\nexport function extractColor(color?: ColorType) {\r\n  if (color == null) {\r\n    return null;\r\n  }\r\n  return toHex(new Color(color));\r\n}\r\n\r\nexport function extractStrokeJoin(strokeJoin?: StrokeJoin) {\r\n  switch (strokeJoin) {\r\n    case 'miter':\r\n      return 0;\r\n    case 'bevel':\r\n      return 2;\r\n    default:\r\n      return 1; // round\r\n  }\r\n}\r\n\r\nexport function extractStrokeCap(strokeCap?: StrokeCap) {\r\n  switch (strokeCap) {\r\n    case 'butt':\r\n      return 0;\r\n    case 'square':\r\n      return 2;\r\n    default:\r\n      return 1; // round\r\n  }\r\n}\r\n\r\nconst SOLID_COLOR = 0;\r\nconst LINEAR_GRADIENT = 1;\r\nconst RADIAL_GRADIENT = 2;\r\nconst PATTERN = 3;\r\n\r\n// TODO: Refactor and simplify applyBoundingBoxToBrushData and extractBrush\r\n\r\nfunction applyBoundingBoxToBrushData(\r\n  brushData: Array<number>,\r\n  props: {width: number, height: number},\r\n) {\r\n  const type = brushData[0];\r\n  const width = +props.width;\r\n  const height = +props.height;\r\n  if (type === LINEAR_GRADIENT) {\r\n    brushData[1] *= width;\r\n    brushData[2] *= height;\r\n    brushData[3] *= width;\r\n    brushData[4] *= height;\r\n  } else if (type === RADIAL_GRADIENT) {\r\n    brushData[1] *= width;\r\n    brushData[2] *= height;\r\n    brushData[3] *= width;\r\n    brushData[4] *= height;\r\n    brushData[5] *= width;\r\n    brushData[6] *= height;\r\n  } else if (type === PATTERN) {\r\n    // todo\r\n  }\r\n}\r\n\r\nexport function extractBrush(\r\n  colorOrBrush?: Brush | string,\r\n  props: {width: number, height: number},\r\n) {\r\n  if (colorOrBrush == null) {\r\n    return null;\r\n  }\r\n  if (colorOrBrush._brush) {\r\n    if (colorOrBrush._bb) {\r\n      // The legacy API for Gradients allow for the bounding box to be used\r\n      // as a convenience for specifying gradient positions. This should be\r\n      // deprecated. It's not properly implemented in canvas mode. ReactART\r\n      // doesn't handle update to the bounding box correctly. That's why we\r\n      // mutate this so that if it's reused, we reuse the same resolved box.\r\n\r\n      // $FlowFixMe\r\n      applyBoundingBoxToBrushData(colorOrBrush._brush, props);\r\n      // $FlowFixMe\r\n      colorOrBrush._bb = false;\r\n    }\r\n    return colorOrBrush._brush;\r\n  }\r\n  const c = new Color(colorOrBrush);\r\n  return [SOLID_COLOR, c.red / 255, c.green / 255, c.blue / 255, c.alpha];\r\n}\r\n\r\nexport function extractAlignment(alignment?: Alignment) {\r\n  switch (alignment) {\r\n    case 'right':\r\n      return 1;\r\n    case 'center':\r\n      return 2;\r\n    default:\r\n      return 0; // left\r\n  }\r\n}\r\n\r\nconst cachedFontObjectsFromString = {};\r\n\r\nconst fontFamilyPrefix = /^[\\s\"']*/;\r\nconst fontFamilySuffix = /[\\s\"']*$/;\r\n\r\nfunction extractSingleFontFamily(fontFamilyString: string) {\r\n  // ART on the web allows for multiple font-families to be specified.\r\n  // For compatibility, we extract the first font-family, hoping\r\n  // we'll get a match.\r\n  return fontFamilyString\r\n    .split(',')[0]\r\n    .replace(fontFamilyPrefix, '')\r\n    .replace(fontFamilySuffix, '');\r\n}\r\n\r\nfunction parseFontString(font: string) {\r\n  if (cachedFontObjectsFromString.hasOwnProperty(font)) {\r\n    return cachedFontObjectsFromString[font];\r\n  }\r\n  const regexp = /^\\s*((?:(?:normal|bold|italic)\\s+)*)(?:(\\d+(?:\\.\\d+)?)[ptexm\\%]*(?:\\s*\\/.*?)?\\s+)?\\s*\\\"?([^\\\"]*)/i;\r\n  const match = regexp.exec(font);\r\n  if (!match) {\r\n    return null;\r\n  }\r\n  const fontFamily = extractSingleFontFamily(match[3]);\r\n  const fontSize = +match[2] || 12;\r\n  const isBold = /bold/.exec(match[1]);\r\n  const isItalic = /italic/.exec(match[1]);\r\n  cachedFontObjectsFromString[font] = {\r\n    fontFamily: fontFamily,\r\n    fontSize: fontSize,\r\n    fontWeight: isBold ? 'bold' : 'normal',\r\n    fontStyle: isItalic ? 'italic' : 'normal',\r\n  };\r\n  return cachedFontObjectsFromString[font];\r\n}\r\n\r\nfunction extractFont(font?: string | Font) {\r\n  if (font == null) {\r\n    return null;\r\n  }\r\n  if (typeof font === 'string') {\r\n    return parseFontString(font);\r\n  }\r\n  const fontFamily = extractSingleFontFamily(font.fontFamily);\r\n  const fontSize = +font.fontSize || 12;\r\n  const fontWeight =\r\n    font.fontWeight != null ? font.fontWeight.toString() : '400';\r\n  return {\r\n    // Normalize\r\n    fontFamily: fontFamily,\r\n    fontSize: fontSize,\r\n    fontWeight: fontWeight,\r\n    fontStyle: font.fontStyle,\r\n  };\r\n}\r\n\r\nconst newLine = /\\n/g;\r\nexport function extractFontAndLines(font?: string | Font, text: string) {\r\n  return {font: extractFont(font), lines: text.split(newLine)};\r\n}\r\n\r\nfunction insertColorIntoArray(color: ColorType, targetArray, atIndex) {\r\n  const c = new Color(color);\r\n  targetArray[atIndex + 0] = c.red / 255;\r\n  targetArray[atIndex + 1] = c.green / 255;\r\n  targetArray[atIndex + 2] = c.blue / 255;\r\n  targetArray[atIndex + 3] = c.alpha;\r\n}\r\n\r\nfunction insertColorsIntoArray(\r\n  stops: GradientStops,\r\n  targetArray: Array<number>,\r\n  atIndex: number,\r\n) {\r\n  let i = 0;\r\n  if ('length' in stops) {\r\n    // $FlowFixMe: stops is Array here\r\n    while (i < stops.length) {\r\n      // $FlowFixMe: stops is Array here\r\n      insertColorIntoArray(stops[i], targetArray, atIndex + i * 4);\r\n      i++;\r\n    }\r\n  } else {\r\n    // $FlowFixMe stops is Object here\r\n    for (const offset in stops) {\r\n      insertColorIntoArray(stops[offset], targetArray, atIndex + i * 4);\r\n      i++;\r\n    }\r\n  }\r\n  return atIndex + i * 4;\r\n}\r\n\r\nfunction insertOffsetsIntoArray(\r\n  stops: GradientStops,\r\n  targetArray: Array<number>,\r\n  atIndex: number,\r\n  multi: number,\r\n  reverse: boolean,\r\n) {\r\n  let offsetNumber;\r\n  let i = 0;\r\n  if ('length' in stops) {\r\n    // $FlowFixMe: stops is Array here\r\n    while (i < stops.length) {\r\n      // $FlowFixMe: stops is Array here\r\n      offsetNumber = (i / (stops.length - 1)) * multi;\r\n      targetArray[atIndex + i] = reverse ? 1 - offsetNumber : offsetNumber;\r\n      i++;\r\n    }\r\n  } else {\r\n    // $FlowFixMe stops is Object here\r\n    for (const offsetString in stops) {\r\n      offsetNumber = +offsetString * multi;\r\n      targetArray[atIndex + i] = reverse ? 1 - offsetNumber : offsetNumber;\r\n      i++;\r\n    }\r\n  }\r\n  return atIndex + i;\r\n}\r\n\r\nexport function insertColorStopsIntoArray(\r\n  stops: GradientStops,\r\n  targetArray: Array<number>,\r\n  atIndex: number,\r\n) {\r\n  const lastIndex = insertColorsIntoArray(stops, targetArray, atIndex);\r\n  insertOffsetsIntoArray(stops, targetArray, lastIndex, 1, false);\r\n}\r\n\r\nexport function insertDoubleColorStopsIntoArray(\r\n  stops: GradientStops,\r\n  targetArray: Array<number>,\r\n  atIndex: number,\r\n) {\r\n  let lastIndex = insertColorsIntoArray(stops, targetArray, atIndex);\r\n  lastIndex = insertColorsIntoArray(stops, targetArray, lastIndex);\r\n  lastIndex = insertOffsetsIntoArray(stops, targetArray, lastIndex, 0.5, false);\r\n  insertOffsetsIntoArray(stops, targetArray, lastIndex, 0.5, true);\r\n}\r\n"]},"metadata":{},"sourceType":"module"}