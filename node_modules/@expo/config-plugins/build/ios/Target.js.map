{"version":3,"file":"Target.js","sourceRoot":"","sources":["../../src/ios/Target.ts"],"names":[],"mappings":";;;;;AAAA,gDAAwB;AAExB,sCAA4C;AAC5C,mCAA0C;AAkBnC,KAAK,UAAU,kCAAkC,CACtD,WAAmB,EACnB,MAAc;;IAEd,MAAM,cAAc,GAAG,uBAAe,CAAC,WAAW,CAAC,CAAC;IACpD,MAAM,EAAE,GAAG,IAAI,MAAM,CAAC,IAAI,MAAM,WAAW,CAAC,CAAC;IAC7C,MAAM,UAAU,GAAG,cAAc,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IACxD,IAAI,CAAC,UAAU,EAAE;QACf,MAAM,IAAI,KAAK,CAAC,WAAW,MAAM,kBAAkB,CAAC,CAAC;KACtD;IAED,MAAM,SAAS,GAAI,CAAC,MAAM,kBAAY,CAAC,EAAE,IAAI,EAAE,UAAU,EAAE,CAAC,CAA0B,CAAC;IACvF,MAAM,UAAU,+DACd,SAAS,CAAC,MAAM,0CAAE,WAAW,0CAAG,CAAC,2CAAG,kBAAkB,0CAAG,CAAC,2CAAG,gBAAgB,0CAAG,CAAC,2CAC7E,kBAAkB,0CAAG,CAAC,2CAAI,GAAG,2CAAG,aAAa,CAAC;IACpD,IAAI,CAAC,UAAU,EAAE;QACf,MAAM,kBAAkB,GAAG,cAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,UAAU,CAAC,CAAC;QAClE,MAAM,IAAI,KAAK,CAAC,GAAG,kBAAkB,wBAAwB,CAAC,CAAC;KAChE;IACD,OAAO,UAAU,CAAC;AACpB,CAAC;AApBD,gFAoBC","sourcesContent":["import path from 'path';\n\nimport { readXMLAsync } from '../utils/XML';\nimport { findSchemePaths } from './Paths';\n\ninterface SchemeXML {\n  Scheme?: {\n    BuildAction?: {\n      BuildActionEntries?: {\n        BuildActionEntry?: {\n          BuildableReference?: {\n            $?: {\n              BlueprintName?: string;\n            };\n          }[];\n        }[];\n      }[];\n    }[];\n  };\n}\n\nexport async function getApplicationTargetForSchemeAsync(\n  projectRoot: string,\n  scheme: string\n): Promise<string> {\n  const allSchemePaths = findSchemePaths(projectRoot);\n  const re = new RegExp(`/${scheme}.xcscheme`);\n  const schemePath = allSchemePaths.find(i => re.exec(i));\n  if (!schemePath) {\n    throw new Error(`scheme '${scheme}' does not exist`);\n  }\n\n  const schemeXML = ((await readXMLAsync({ path: schemePath })) as unknown) as SchemeXML;\n  const targetName =\n    schemeXML.Scheme?.BuildAction?.[0]?.BuildActionEntries?.[0]?.BuildActionEntry?.[0]\n      ?.BuildableReference?.[0]?.['$']?.BlueprintName;\n  if (!targetName) {\n    const schemeRelativePath = path.relative(projectRoot, schemePath);\n    throw new Error(`${schemeRelativePath} seems to be corrupted`);\n  }\n  return targetName;\n}\n"]}