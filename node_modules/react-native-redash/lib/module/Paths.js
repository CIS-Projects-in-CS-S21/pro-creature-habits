import Animated,{interpolate}from"react-native-reanimated";import parseSVG from"parse-svg-path";import absSVG from"abs-svg-path";import normalizeSVG from"normalize-svg-path";import{cubicBezierYForX}from"./Math";export var SVGCommand;(function(SVGCommand){SVGCommand[SVGCommand["MOVE"]=0]="MOVE";SVGCommand[SVGCommand["CURVE"]=1]="CURVE";SVGCommand[SVGCommand["CLOSE"]=2]="CLOSE";})(SVGCommand||(SVGCommand={}));export var exhaustiveCheck=function exhaustiveCheck(command){"worklet";throw new TypeError("Unknown SVG Command: "+command);};var serializeMove=function serializeMove(c){"worklet";return"M"+c.x+","+c.y+" ";};var serializeClose=function serializeClose(){"worklet";return"Z";};var serializeCurve=function serializeCurve(c){"worklet";return"C"+c.c1.x+","+c.c1.y+" "+c.c2.x+","+c.c2.y+" "+c.to.x+","+c.to.y+" ";};var isMove=function isMove(command){"worklet";return command.type===SVGCommand.MOVE;};var isCurve=function isCurve(command){"worklet";return command.type===SVGCommand.CURVE;};var isClose=function isClose(command){"worklet";return command.type===SVGCommand.CLOSE;};export var serialize=function serialize(path){"worklet";return path.map(function(segment){if(isMove(segment)){return serializeMove(segment);}if(isCurve(segment)){return serializeCurve(segment);}if(isClose(segment)){return serializeClose();}return exhaustiveCheck(segment);}).reduce(function(acc,c){return acc+c;});};export var parse=function parse(d){var segments=normalizeSVG(absSVG(parseSVG(d)));return segments.map(function(segment,index){if(segment[0]==="M"){return moveTo(segment[1],segment[2]);}else if(segment[0]==="Z"){return close();}else{var _ref,_ref2;var prev=segments[index-1];var r=curve({c1:{x:segment[1],y:segment[2]},c2:{x:segment[3],y:segment[4]},to:{x:segment[5],y:segment[6]},from:{x:(_ref=prev[0]==="M"?prev[1]:prev[5])!=null?_ref:0,y:(_ref2=prev[0]==="M"?prev[2]:prev[6])!=null?_ref2:0}});return r;}});};export var interpolatePath=function interpolatePath(value,inputRange,outputRange){"worklet";var extrapolate=arguments.length>3&&arguments[3]!==undefined?arguments[3]:Animated.Extrapolate.CLAMP;var path=outputRange[0].map(function(segment,index){if(isMove(segment)){var points=outputRange.map(function(p){var s=p[index];if(isMove(s)){return{x:s.x,y:s.y};}throw new Error("Paths to interpolate are not symetrical");});return{type:SVGCommand.MOVE,x:interpolate(value,inputRange,points.map(function(p){return p.x;}),extrapolate),y:interpolate(value,inputRange,points.map(function(p){return p.y;}),extrapolate)};}if(isCurve(segment)){var curves=outputRange.map(function(p){var s=p[index];if(isCurve(s)){return{to:s.to,c1:s.c1,c2:s.c2};}throw new Error("Paths to interpolate are not symetrical");});return{type:SVGCommand.CURVE,to:{x:interpolate(value,inputRange,curves.map(function(c){return c.to.x;}),extrapolate),y:interpolate(value,inputRange,curves.map(function(c){return c.to.y;}),extrapolate)},c1:{x:interpolate(value,inputRange,curves.map(function(c){return c.c1.x;}),extrapolate),y:interpolate(value,inputRange,curves.map(function(c){return c.c1.y;}),extrapolate)},c2:{x:interpolate(value,inputRange,curves.map(function(c){return c.c2.x;}),extrapolate),y:interpolate(value,inputRange,curves.map(function(c){return c.c2.y;}),extrapolate)}};}return segment;});return serialize(path);};export var mixPath=function mixPath(value,p1,p2){"worklet";var extrapolate=arguments.length>3&&arguments[3]!==undefined?arguments[3]:Animated.Extrapolate.CLAMP;return interpolatePath(value,[0,1],[p1,p2],extrapolate);};export var moveTo=function moveTo(x,y){"worklet";return{type:SVGCommand.MOVE,x:x,y:y};};export var curve=function curve(c){"worklet";return{type:SVGCommand.CURVE,c1:c.c1,c2:c.c2,to:c.to,from:c.from};};export var close=function close(){"worklet";return{type:SVGCommand.CLOSE};};export var getYForX=function getYForX(path,x){"worklet";var precision=arguments.length>2&&arguments[2]!==undefined?arguments[2]:2;var p=path.filter(function(c){if(isCurve(c)){if(c.from.x>c.to.x){return x>=c.to.x&&x<=c.from.x;}return x>=c.from.x&&x<=c.to.x;}return false;});if(p.length>0&&isCurve(p[0])){return cubicBezierYForX(x,p[0].from,p[0].c1,p[0].c2,p[0].to,precision);}return 0;};
//# sourceMappingURL=Paths.js.map