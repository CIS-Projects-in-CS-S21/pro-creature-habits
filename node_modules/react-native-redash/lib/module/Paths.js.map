{"version":3,"sources":["Paths.ts"],"names":["Animated","interpolate","parseSVG","absSVG","normalizeSVG","cubicBezierYForX","SVGCommand","exhaustiveCheck","command","TypeError","serializeMove","c","x","y","serializeClose","serializeCurve","c1","c2","to","isMove","type","MOVE","isCurve","CURVE","isClose","CLOSE","serialize","path","map","segment","reduce","acc","parse","d","segments","index","moveTo","close","prev","r","curve","from","interpolatePath","value","inputRange","outputRange","extrapolate","Extrapolate","CLAMP","points","p","s","Error","curves","mixPath","p1","p2","getYForX","precision","filter","length"],"mappings":"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","sourcesContent":["import Animated, { interpolate } from \"react-native-reanimated\";\nimport parseSVG from \"parse-svg-path\";\nimport absSVG from \"abs-svg-path\";\nimport normalizeSVG from \"normalize-svg-path\";\n\nimport { Vector } from \"./Vectors\";\nimport { cubicBezierYForX } from \"./Math\";\n\ntype SVGCloseCommand = [\"Z\"];\ntype SVGMoveCommand = [\"M\", number, number];\ntype SVGCurveCommand = [\"C\", number, number, number, number, number, number];\ntype SVGNormalizedCommands = [\n  SVGMoveCommand | SVGCurveCommand | SVGCloseCommand\n];\n\nexport enum SVGCommand {\n  MOVE,\n  CURVE,\n  CLOSE,\n}\n\ninterface Move extends Vector {\n  type: SVGCommand.MOVE;\n}\n\ninterface Curve {\n  type: SVGCommand.CURVE;\n  from: Vector;\n  to: Vector;\n  c1: Vector;\n  c2: Vector;\n}\n\ninterface Close {\n  type: SVGCommand.CLOSE;\n}\n\nexport type Segment = Close | Curve | Move;\nexport type Path = Segment[];\n\nexport const exhaustiveCheck = (command: never): never => {\n  \"worklet\";\n  throw new TypeError(`Unknown SVG Command: ${command}`);\n};\n\nconst serializeMove = (c: Move) => {\n  \"worklet\";\n  return `M${c.x},${c.y} `;\n};\n\nconst serializeClose = () => {\n  \"worklet\";\n  return \"Z\";\n};\n\nconst serializeCurve = (c: Curve) => {\n  \"worklet\";\n  return `C${c.c1.x},${c.c1.y} ${c.c2.x},${c.c2.y} ${c.to.x},${c.to.y} `;\n};\n\nconst isMove = (command: Segment): command is Move => {\n  \"worklet\";\n  return command.type === SVGCommand.MOVE;\n};\n\nconst isCurve = (command: Segment): command is Curve => {\n  \"worklet\";\n  return command.type === SVGCommand.CURVE;\n};\n\nconst isClose = (command: Segment): command is Close => {\n  \"worklet\";\n  return command.type === SVGCommand.CLOSE;\n};\n\n/**\n * @summary Serialize a path into an SVG path string\n */\nexport const serialize = (path: Path) => {\n  \"worklet\";\n  return path\n    .map((segment) => {\n      if (isMove(segment)) {\n        return serializeMove(segment);\n      }\n      if (isCurve(segment)) {\n        return serializeCurve(segment);\n      }\n      if (isClose(segment)) {\n        return serializeClose();\n      }\n      return exhaustiveCheck(segment);\n    })\n    .reduce((acc, c) => acc + c);\n};\n\n/**\n * @description ⚠️ this function cannot run on the UI thread. It must be executed on the JS thread\n * @summary Parse an SVG path into a sequence of Bèzier curves.\n * The SVG is normalized to have absolute values and to be approximated to a sequence of Bèzier curves.\n */\nexport const parse = (d: string): Path => {\n  const segments: SVGNormalizedCommands = normalizeSVG(absSVG(parseSVG(d)));\n  return segments.map((segment, index) => {\n    if (segment[0] === \"M\") {\n      return moveTo(segment[1], segment[2]);\n    } else if (segment[0] === \"Z\") {\n      return close();\n    } else {\n      const prev = segments[index - 1];\n      const r = curve({\n        c1: {\n          x: segment[1],\n          y: segment[2],\n        },\n        c2: {\n          x: segment[3],\n          y: segment[4],\n        },\n        to: {\n          x: segment[5],\n          y: segment[6],\n        },\n        from: {\n          x: (prev[0] === \"M\" ? prev[1] : prev[5]) ?? 0,\n          y: (prev[0] === \"M\" ? prev[2] : prev[6]) ?? 0,\n        },\n      });\n      return r;\n    }\n  });\n};\n\n/**\n * @summary Interpolate between paths.\n */\nexport const interpolatePath = (\n  value: number,\n  inputRange: number[],\n  outputRange: Path[],\n  extrapolate = Animated.Extrapolate.CLAMP\n) => {\n  \"worklet\";\n  const path = outputRange[0].map((segment, index) => {\n    if (isMove(segment)) {\n      const points = outputRange.map((p) => {\n        const s = p[index];\n        if (isMove(s)) {\n          return {\n            x: s.x,\n            y: s.y,\n          };\n        }\n        throw new Error(\"Paths to interpolate are not symetrical\");\n      });\n      return {\n        type: SVGCommand.MOVE,\n        x: interpolate(\n          value,\n          inputRange,\n          points.map((p) => p.x),\n          extrapolate\n        ),\n        y: interpolate(\n          value,\n          inputRange,\n          points.map((p) => p.y),\n          extrapolate\n        ),\n      } as Move;\n    }\n    if (isCurve(segment)) {\n      const curves = outputRange.map((p) => {\n        const s = p[index];\n        if (isCurve(s)) {\n          return {\n            to: s.to,\n            c1: s.c1,\n            c2: s.c2,\n          };\n        }\n        throw new Error(\"Paths to interpolate are not symetrical\");\n      });\n      return {\n        type: SVGCommand.CURVE,\n        to: {\n          x: interpolate(\n            value,\n            inputRange,\n            curves.map((c) => c.to.x),\n            extrapolate\n          ),\n          y: interpolate(\n            value,\n            inputRange,\n            curves.map((c) => c.to.y),\n            extrapolate\n          ),\n        },\n        c1: {\n          x: interpolate(\n            value,\n            inputRange,\n            curves.map((c) => c.c1.x),\n            extrapolate\n          ),\n          y: interpolate(\n            value,\n            inputRange,\n            curves.map((c) => c.c1.y),\n            extrapolate\n          ),\n        },\n        c2: {\n          x: interpolate(\n            value,\n            inputRange,\n            curves.map((c) => c.c2.x),\n            extrapolate\n          ),\n          y: interpolate(\n            value,\n            inputRange,\n            curves.map((c) => c.c2.y),\n            extrapolate\n          ),\n        },\n      } as Curve;\n    }\n    return segment;\n  });\n  return serialize(path);\n};\n\n/**\n * @summary Interpolate two paths with an animation value that goes from 0 to 1\n */\nexport const mixPath = (\n  value: number,\n  p1: Path,\n  p2: Path,\n  extrapolate = Animated.Extrapolate.CLAMP\n) => {\n  \"worklet\";\n  return interpolatePath(value, [0, 1], [p1, p2], extrapolate);\n};\n\n/**\n * @summary Returns a Bèzier curve command.\n */\nexport const moveTo = (x: number, y: number) => {\n  \"worklet\";\n  return { type: SVGCommand.MOVE as const, x, y };\n};\n\n/**\n * @summary Returns a Bèzier curve command\n */\nexport const curve = (c: Omit<Curve, \"type\">) => {\n  \"worklet\";\n  return {\n    type: SVGCommand.CURVE as const,\n    c1: c.c1,\n    c2: c.c2,\n    to: c.to,\n    from: c.from,\n  };\n};\n\n/**\n * @summary Returns a close command.\n */\nexport const close = () => {\n  \"worklet\";\n  return { type: SVGCommand.CLOSE as const };\n};\n\n/**\n * @summary Return the y value of a path given its x coordinate\n * @example\n    const p1 = parse(\n      \"M150,0 C150,0 0,75 200,75 C75,200 200,225 200,225 C225,200 200,150 0,150\"\n    );\n    // 75\n    getYForX(p1, 200))\n    // ~151\n    getYForX(p1, 50)\n */\nexport const getYForX = (path: Path, x: number, precision = 2) => {\n  \"worklet\";\n  const p = path.filter((c) => {\n    if (isCurve(c)) {\n      if (c.from.x > c.to.x) {\n        return x >= c.to.x && x <= c.from.x;\n      }\n      return x >= c.from.x && x <= c.to.x;\n    }\n    return false;\n  });\n  if (p.length > 0 && isCurve(p[0])) {\n    return cubicBezierYForX(x, p[0].from, p[0].c1, p[0].c2, p[0].to, precision);\n  }\n  return 0;\n};\n"]}